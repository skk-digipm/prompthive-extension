// Enhanced Popup script for PromptHive with improved database integration
// Import database manager
let dbManager = null;

// Global reference for event handlers
let promptHive;

// Initialize the app when DOM is loaded
document.addEventListener("DOMContentLoaded", async () => {
  console.log('DOM loaded, initializing PromptHive...');
  try {
    // Initialize database manager first
    if (typeof PromptHiveDatabase !== 'undefined') {
      dbManager = new PromptHiveDatabase();
      await dbManager.init();
    }
    promptHive = new PromptHive();
  } catch (error) {
    console.error('Failed to initialize database manager:', error);
    promptHive = new PromptHive();
  }
});

class PromptHivePopup {
  setupKeyboardShortcuts() {
    document.addEventListener("keydown", (e) => {
      // Escape to close modals
      if (e.key === "Escape") {
        this.closeModal();
        this.closeEnhancementModal();
        this.closeHistoryModal();
        this.closeDashboard();
      }
      
      // Ctrl/Cmd + K to focus search
      if ((e.ctrlKey || e.metaKey) && e.key === "k") {
        e.preventDefault();
        const searchInput = document.getElementById("searchInput");
        if (searchInput) searchInput.focus();
      }

      // Ctrl/Cmd + N to add new prompt
      if ((e.ctrlKey || e.metaKey) && e.key === "n") {
        e.preventDefault();
        this.openModal();
      }

      // Ctrl/Cmd + D to open dashboard
      if ((e.ctrlKey || e.metaKey) && e.key === "d") {
        e.preventDefault();
        this.openDashboard();
      }

      // Enter to save when modal is open
      if (e.key === "Enter" && e.ctrlKey) {
        const modalOverlay = document.getElementById("modalOverlay");
        if (modalOverlay && modalOverlay.style.display === "flex") {
          e.preventDefault();
          this.savePrompt();
        }
      }
    });
  }

  search(query) {
    const searchTerm = query.toLowerCase().trim();
    
    if (!searchTerm) {
      this.filteredPrompts = this.prompts;
    } else {
      this.filteredPrompts = this.prompts.filter(prompt => 
        prompt.title.toLowerCase().includes(searchTerm) ||
        prompt.text.toLowerCase().includes(searchTerm) ||
        prompt.tags.some(tag => tag.toLowerCase().includes(searchTerm))
      );
    }
    
    this.render();
  }

  render() {
    const container = document.getElementById("promptList");
    if (!container) {
      console.error('promptList container not found');
      return;
    }
    
    if (this.filteredPrompts.length === 0) {
      container.innerHTML = this.renderEmptyState();
      return;
    }

    container.innerHTML = this.filteredPrompts.map((prompt, index) => 
      this.renderPromptCard(prompt, index)
    ).join("");

    // Bind card events
    this.bindCardEvents();
  }

  renderPromptCard(prompt, index) {
    const originalIndex = this.prompts.findIndex(p => p.id === prompt.id);
    const truncatedText = prompt.text.length > 150 ? 
      prompt.text.substring(0, 150) + "..." : prompt.text;

    return `
      <div class="prompt-card" data-index="${originalIndex}">
        <div class="prompt-header">
          <div class="prompt-title">${this.escapeHtml(prompt.title)}</div>
          <div class="prompt-id">#${prompt.id.slice(-6)}</div>
        </div>
        <div class="prompt-meta">
          <div class="meta-left">
            <div class="meta-item">
              <span>üìÖ</span>
              <span>${prompt.date}</span>
            </div>
            <div class="meta-item">
              <span>üìä</span>
              <span>${prompt.uses} uses</span>
            </div>
            ${prompt.version ? `
              <div class="meta-item">
                <span>üìù</span>
                <span>v${prompt.version}</span>
              </div>
            ` : ''}
          </div>
          <div class="meta-right">
            <button class="icon-btn history-btn" data-index="${originalIndex}" data-tooltip="View History">
              <span>üïí</span>
            </button>
            <button class="icon-btn edit-btn" data-index="${originalIndex}" data-tooltip="Edit Prompt">
              <span>‚úèÔ∏è</span>
            </button>
            <button class="icon-btn delete-btn" data-index="${originalIndex}" data-tooltip="Delete Prompt">
              <span>üóëÔ∏è</span>
            </button>
          </div>
        </div>
        <div class="prompt-content">${this.escapeHtml(truncatedText)}</div>
        ${prompt.tags.length > 0 ? `
          <div class="tags">
            ${prompt.tags.map(tag => `<span class="tag">${this.escapeHtml(tag)}</span>`).join("")}
          </div>
        ` : ""}
        <div class="actions">
          <button class="action-btn primary copy-btn" data-index="${originalIndex}">
            <span>üìã</span>
            Copy & Use
          </button>
          <button class="action-btn enhance-btn" data-index="${originalIndex}">
            <span>ü§ñ</span>
            AI Enhance
          </button>
        </div>
      </div>
    `;
  }

  renderEmptyState() {
    const isSearching = document.getElementById("searchInput")?.value?.trim() !== "";
    
    if (isSearching) {
      return `
        <div class="empty-state">
          <div class="empty-state-icon">üîç</div>
          <h3>No prompts found</h3>
          <p>Try adjusting your search terms or add a new prompt.</p>
        </div>
      `;
    }

    return `
      <div class="empty-state">
        <div class="empty-state-icon">üè†</div>
        <h3>Welcome to PromptHive!</h3>
        <p>Start building your prompt collection by adding your first prompt or right-clicking on any text to save it.</p>
      </div>
    `;
  }

  bindCardEvents() {
    // Copy buttons
    document.querySelectorAll(".copy-btn").forEach(btn => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const index = parseInt(btn.dataset.index);
        this.copyPrompt(index);
      });
    });

    // Enhance buttons
    document.querySelectorAll(".enhance-btn").forEach(btn => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const index = parseInt(btn.dataset.index);
        this.enhancePrompt(index);
      });
    });

    // Edit buttons
    document.querySelectorAll(".edit-btn").forEach(btn => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const index = parseInt(btn.dataset.index);
        this.editPrompt(index);
      });
    });

    // Delete buttons
    document.querySelectorAll(".delete-btn").forEach(btn => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const index = parseInt(btn.dataset.index);
        this.deletePrompt(index);
      });
    });

    // History buttons
    document.querySelectorAll(".history-btn").forEach(btn => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const index = parseInt(btn.dataset.index);
        this.showPromptHistory(index);
      });
    });
  }

  async copyPrompt(index) {
    const prompt = this.prompts[index];
    
    try {
      await navigator.clipboard.writeText(prompt.text);
      
      // Increment usage counter
      this.prompts[index].uses++;
      this.prompts[index].updatedAt = new Date().toISOString();
      
      if (this.dbManager) {
        await this.dbManager.updatePrompt(this.prompts[index]);
      }
      
      // Update display and stats
      this.search(document.getElementById("searchInput").value);
      this.calculateStats();
      this.updateStats();
      
      this.showNotification("Prompt copied to clipboard!");
    } catch (err) {
      console.error("Failed to copy text: ", err);
      this.showNotification("Failed to copy prompt", "error");
    }
  }

  async enhancePrompt(index) {
    const prompt = this.prompts[index];
    
    // Show enhancement modal with loading state
    this.showEnhancementModal(prompt.text, "", true);
    
    try {
      const enhanced = await this.enhanceWithAI(prompt.text);
      this.showEnhancementModal(prompt.text, enhanced, false);
      this.currentEnhancingIndex = index;
    } catch (error) {
      console.error("AI enhancement failed:", error);
      this.showNotification("AI enhancement failed. Please try again.", "error");
      this.closeEnhancementModal();
    }
  }

  editPrompt(index) {
    this.editingIndex = index;
    const prompt = this.prompts[index];
    
    document.getElementById("modalTitle").textContent = "Edit Prompt";
    document.getElementById("promptTitle").value = prompt.title;
    document.getElementById("promptText").value = prompt.text;
    document.getElementById("promptTags").value = prompt.tags.join(", ");
    
    this.openModal();
  }

  async deletePrompt(index) {
    const prompt = this.prompts[index];
    
    if (confirm(`Delete "${prompt.title}"?\n\nThis action cannot be undone.`)) {
      try {
        // Delete from IndexedDB
        if (this.dbManager) {
          await this.dbManager.deletePrompt(prompt.id);
        }
        
        // Remove from memory
        this.prompts.splice(index, 1);
        
        this.search(document.getElementById("searchInput").value);
        this.calculateStats();
        this.updateStats();
        this.showNotification("Prompt deleted successfully");
      } catch (error) {
        console.error("Failed to delete prompt:", error);
        this.showNotification("Failed to delete prompt", "error");
      }
    }
  }

  async showPromptHistory(index) {
    const prompt = this.prompts[index];
    
    try {
      const history = await this.getPromptHistory(prompt.id);
      this.renderHistoryModal(prompt, history);
    } catch (error) {
      console.error("Failed to load history:", error);
      this.showNotification("Failed to load prompt history", "error");
    }
  }

  renderHistoryModal(prompt, history) {
    document.getElementById("historyPromptTitle").textContent = prompt.title;
    
    const historyList = document.getElementById("historyList");
    
    if (history.length === 0) {
      historyList.innerHTML = `
        <div class="history-empty">
          <p>No history available for this prompt yet.</p>
        </div>
      `;
    } else {
      historyList.innerHTML = history.map(entry => `
        <div class="history-entry">
          <div class="history-header">
            <span class="history-version">Version ${entry.version}</span>
            <span class="history-date">${new Date(entry.createdAt).toLocaleString()}</span>
          </div>
          <div class="history-content">
            <strong>Title:</strong> ${this.escapeHtml(entry.title)}<br>
            <strong>Content:</strong> ${this.escapeHtml(entry.text.substring(0, 200))}${entry.text.length > 200 ? '...' : ''}
          </div>
          <div class="history-actions">
            <button class="action-btn restore-btn" data-history-id="${entry.historyId}" data-prompt-id="${prompt.id}">
              <span>‚Ü∂</span> Restore
            </button>
          </div>
        </div>
      `).join("");
      
      // FIXED: Bind restore buttons with proper event listeners
      historyList.querySelectorAll('.restore-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const historyId = btn.dataset.historyId;
          const promptId = btn.dataset.promptId;
          this.restoreFromHistory(historyId, promptId);
        });
      });
    }
    
    document.getElementById("historyModalOverlay").style.display = "flex";
  }

  async restoreFromHistory(historyId, promptId) {
    try {
      if (!this.dbManager) {
        throw new Error('Database not available');
      }

      // Get history entry
      const historyEntry = await this.dbManager.getHistoryEntry(historyId);
      
      if (!historyEntry) {
        throw new Error('History entry not found');
      }
      
      // Find current prompt
      const promptIndex = this.prompts.findIndex(p => p.id === promptId);
      if (promptIndex === -1) {
        throw new Error('Prompt not found');
      }
      
      const currentPrompt = this.prompts[promptIndex];
      
      // Save current version to history before restoring
      const currentVersion = currentPrompt.version || 1;
      await this.savePromptHistory(promptId, currentPrompt, currentVersion);
      
      // Restore from history
      const restoredPrompt = {
        ...currentPrompt,
        title: historyEntry.title,
        text: historyEntry.text,
        tags: historyEntry.tags,
        version: (currentVersion + 1),
        updatedAt: new Date().toISOString()
      };
      
      // Update in memory and database
      this.prompts[promptIndex] = restoredPrompt;
      await this.dbManager.updatePrompt(restoredPrompt);
      
      this.closeHistoryModal();
      this.search(document.getElementById("searchInput").value);
      this.calculateStats();
      this.updateStats();
      this.showNotification(`Restored to version ${historyEntry.version}`);
      
    } catch (error) {
      console.error("Failed to restore from history:", error);
      this.showNotification("Failed to restore from history", "error");
    }
  }

  showEnhancementModal(original, enhanced, loading = false) {
    document.getElementById("originalPrompt").textContent = original;
    
    const enhancedContainer = document.getElementById("enhancedPrompt");
    const keepEnhancedBtn = document.getElementById("keepEnhancedBtn");
    
    if (loading) {
      enhancedContainer.innerHTML = `
        <div class="loading-enhancement">
          <div class="spinner"></div>
          <p>AI is enhancing your prompt...</p>
        </div>
      `;
      if (keepEnhancedBtn) keepEnhancedBtn.disabled = true;
    } else {
      enhancedContainer.textContent = enhanced;
      if (keepEnhancedBtn) keepEnhancedBtn.disabled = false;
    }
    
    document.getElementById("enhancementModalOverlay").style.display = "flex";
  }

  useOriginalPrompt() {
    this.closeEnhancementModal();
    this.showNotification("Using original prompt");
  }

  async useEnhancedPrompt() {
    const enhancedText = document.getElementById("enhancedPrompt").textContent;
    const prompt = this.prompts[this.currentEnhancingIndex];
    
    try {
      // Save current version to history
      const currentVersion = prompt.version || 1;
      await this.savePromptHistory(prompt.id, prompt, currentVersion);
      
      // Update with enhanced version
      const updatedPrompt = {
        ...prompt,
        text: enhancedText,
        version: currentVersion + 1,
        updatedAt: new Date().toISOString()
      };
      
      this.prompts[this.currentEnhancingIndex] = updatedPrompt;
      
      if (this.dbManager) {
        await this.dbManager.updatePrompt(updatedPrompt);
      }
      
      this.closeEnhancementModal();
      this.search(document.getElementById("searchInput").value);
      this.calculateStats();
      this.updateStats();
      this.showNotification("Prompt enhanced successfully!");
    } catch (error) {
      console.error("Failed to save enhanced prompt:", error);
      this.showNotification("Failed to save enhanced prompt", "error");
    }
  }

  closeEnhancementModal() {
    document.getElementById("enhancementModalOverlay").style.display = "none";
    this.currentEnhancingIndex = null;
  }

  closeHistoryModal() {
    document.getElementById("historyModalOverlay").style.display = "none";
  }

  openDashboard() {
    this.calculateStats();
    this.renderDashboard();
    document.getElementById("dashboardModalOverlay").style.display = "flex";
  }

  closeDashboard() {
    document.getElementById("dashboardModalOverlay").style.display = "none";
  }

  renderDashboard() {
    // Update dashboard stats cards
    document.getElementById("dashTotalPrompts").textContent = this.stats.totalPrompts || 0;
    document.getElementById("dashTotalTags").textContent = this.stats.totalTags || 0;
    document.getElementById("dashTotalUses").textContent = this.stats.totalUses || 0;
    document.getElementById("dashAvgUses").textContent = this.stats.avgUses || 0;

    // Render most used prompts
    const topPrompts = document.getElementById("topPrompts");
    const mostUsed = this.prompts
      .filter(p => p.uses > 0)
      .sort((a, b) => b.uses - a.uses)
      .slice(0, 5);

    if (mostUsed.length === 0) {
      topPrompts.innerHTML = `
        <div class="history-empty">
          <p>No prompts have been used yet.</p>
        </div>
      `;
    } else {
      topPrompts.innerHTML = mostUsed.map(prompt => `
        <div class="history-entry">
          <div class="history-header">
            <span class="history-version">${this.escapeHtml(prompt.title)}</span>
            <span class="history-date">${prompt.uses} uses</span>
          </div>
          <div class="history-content">
            ${this.escapeHtml(prompt.text.substring(0, 100))}${prompt.text.length > 100 ? '...' : ''}
          </div>
        </div>
      `).join("");
    }

    // Render category breakdown
    const categoryBreakdown = document.getElementById("categoryBreakdown");
    if (Object.keys(this.stats.categoryBreakdown).length === 0) {
      categoryBreakdown.innerHTML = `
        <div class="history-empty">
          <p>No categories available yet.</p>
        </div>
      `;
    } else {
      const categoryCards = Object.entries(this.stats.categoryBreakdown)
        .map(([category, count]) => `
          <div class="dashboard-card" style="margin-bottom: 0.5rem;">
            <div class="dashboard-card-icon">${this.getCategoryIcon(category)}</div>
            <div class="dashboard-card-value">${count}</div>
            <div class="dashboard-card-label">${this.capitalizeFirst(category)}</div>
          </div>
        `).join("");
      
      categoryBreakdown.innerHTML = `
        <div class="dashboard-grid" style="margin-bottom: 0;">
          ${categoryCards}
        </div>
      `;
    }

    // Render popular tags
    const popularTags = document.getElementById("popularTags");
    if (this.stats.popularTags.length === 0) {
      popularTags.innerHTML = `<span class="tag">No tags yet</span>`;
    } else {
      popularTags.innerHTML = this.stats.popularTags
        .map(({ tag, count }) => `
          <span class="tag" title="Used ${count} times">${this.escapeHtml(tag)} (${count})</span>
        `).join("");
    }
  }

  getCategoryIcon(category) {
    const icons = {
      'general': 'üìù',
      'coding': 'üíª',
      'writing': '‚úçÔ∏è',
      'analysis': 'üìä',
      'creative': 'üé®',
      'business': 'üíº',
      'education': 'üéì',
      'personal': 'üë§'
    };
    return icons[category] || 'üìÅ';
  }

  capitalizeFirst(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  openModal() {
    if (this.editingIndex === null) {
      document.getElementById("modalTitle").textContent = "Add New Prompt";
      document.getElementById("promptTitle").value = "";
      document.getElementById("promptText").value = "";
      document.getElementById("promptTags").value = "";
    }
    
    document.getElementById("modalOverlay").style.display = "flex";
    setTimeout(() => {
      document.getElementById("promptTitle").focus();
    }, 100);
  }

  closeModal() {
    document.getElementById("modalOverlay").style.display = "none";
    this.editingIndex = null;
    
    // Clear form
    document.getElementById("promptTitle").value = "";
    document.getElementById("promptText").value = "";
    document.getElementById("promptTags").value = "";
  }

  // FIXED: Improved savePrompt method with better error handling and validation
  async savePrompt() {
    console.log('SavePrompt called'); // Debug log
    
    const titleInput = document.getElementById("promptTitle");
    const textInput = document.getElementById("promptText");
    const tagsInput = document.getElementById("promptTags");
    
    if (!titleInput || !textInput || !tagsInput) {
      console.error('Required form elements not found');
      this.showNotification("Form elements not found", "error");
      return;
    }

    const title = titleInput.value.trim();
    const text = textInput.value.trim();
    const tagsInputValue = tagsInput.value.trim();
    
    // Validation
    if (!text) {
      this.showNotification("Prompt content is required", "error");
      textInput.focus();
      return;
    }

    if (text.length < 5) {
      this.showNotification("Prompt content must be at least 5 characters", "error");
      textInput.focus();
      return;
    }

    const tags = tagsInputValue ? 
      tagsInputValue.split(",").map(tag => tag.trim()).filter(tag => tag) : [];

    try {
      if (this.editingIndex !== null) {
        console.log('Editing existing prompt at index:', this.editingIndex);
        
        // Editing existing prompt - save current version to history first
        const currentPrompt = this.prompts[this.editingIndex];
        const currentVersion = currentPrompt.version || 1;
        
        // Save to history before updating
        if (this.dbManager) {
          await this.savePromptHistory(currentPrompt.id, currentPrompt, currentVersion);
        }
        
        const updatedPrompt = {
          ...currentPrompt,
          title: title || "Untitled Prompt",
          text: text,
          tags: tags,
          version: currentVersion + 1,
          updatedAt: new Date().toISOString()
        };
        
        // Update in memory array
        this.prompts[this.editingIndex] = updatedPrompt;
        
        // Save to database
        if (this.dbManager) {
          const saved = await this.dbManager.updatePrompt(updatedPrompt);
          if (!saved) {
            throw new Error('Failed to save to database');
          }
        }
        
        console.log('Prompt updated successfully');
        this.showNotification("Prompt updated successfully");
      } else {
        console.log('Creating new prompt');
        
        // Creating new prompt
        const newPrompt = {
          id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
          title: title || "Untitled Prompt",
          text: text,
          tags: tags,
          date: new Date().toLocaleDateString(),
          uses: 0,
          version: 1,
          category: this.detectCategory(text, tags),
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        
        // Save to database first
        if (this.dbManager) {
          const saved = await this.dbManager.createPrompt(newPrompt);
          if (!saved) {
            throw new Error('Failed to save to database');
          }
        }
        
        // Add to memory array (at beginning for newest first)
        this.prompts.unshift(newPrompt);
        
        console.log('New prompt created successfully:', newPrompt.id);
        this.showNotification("Prompt added successfully");
      }

      // Update UI and stats
      this.search(document.getElementById("searchInput").value);
      this.calculateStats();
      this.updateStats();
      
      // Close modal
      this.closeModal();
      
    } catch (error) {
      console.error("Failed to save prompt:", error);
      this.showNotification("Failed to save prompt. Please try again.", "error");
    }
  }

  // Helper method to detect category based on content
  detectCategory(text, tags = []) {
    const textLower = text.toLowerCase();
    const allTags = tags.map(tag => tag.toLowerCase());
    
    // Check tags first
    if (allTags.includes('coding') || allTags.includes('programming') || allTags.includes('code')) {
      return 'coding';
    }
    if (allTags.includes('writing') || allTags.includes('content')) {
      return 'writing';
    }
    if (allTags.includes('analysis') || allTags.includes('data')) {
      return 'analysis';
    }
    if (allTags.includes('creative') || allTags.includes('design')) {
      return 'creative';
    }
    
    // Check content keywords
    if (textLower.includes('code') || textLower.includes('function') || textLower.includes('javascript') || 
        textLower.includes('python') || textLower.includes('programming') || textLower.includes('api')) {
      return 'coding';
    }
    
    if (textLower.includes('write') || textLower.includes('article') || textLower.includes('blog') || 
        textLower.includes('content') || textLower.includes('copywriting')) {
      return 'writing';
    }
    
    if (textLower.includes('analyze') || textLower.includes('research') || textLower.includes('data') || 
        textLower.includes('study') || textLower.includes('statistics')) {
      return 'analysis';
    }
    
    if (textLower.includes('creative') || textLower.includes('design') || textLower.includes('art') || 
        textLower.includes('brainstorm') || textLower.includes('innovative')) {
      return 'creative';
    }
    
    return 'general';
  }

  exportToCSV() {
    if (this.prompts.length === 0) {
      this.showNotification("No prompts to export", "error");
      return;
    }

    const headers = ["ID", "Title", "Content", "Tags", "Date", "Uses", "Version", "Category", "Created", "Updated"];
    const csvContent = [
      headers.join(","),
      ...this.prompts.map(prompt => [
        `"${prompt.id}"`,
        `"${this.escapeCsv(prompt.title)}"`,
        `"${this.escapeCsv(prompt.text)}"`,
        `"${prompt.tags.join("; ")}"`,
        `"${prompt.date}"`,
        prompt.uses,
        prompt.version || 1,
        `"${prompt.category || 'general'}"`,
        `"${prompt.createdAt || ""}"`,
        `"${prompt.updatedAt || ""}"`
      ].join(","))
    ].join("\n");

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    const url = URL.createObjectURL(blob);
    
    link.setAttribute("href", url);
    link.setAttribute("download", `prompts-${new Date().toISOString().split('T')[0]}.csv`);
    link.style.visibility = "hidden";
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    this.showNotification(`